import { useState } from "preact/hooks";
import { route } from "preact-router";
import type { ParsedRecipe } from "@recipes/shared";
import { generateRecipe, createRecipe } from "../api/client";
import { renderStepText } from "../utils/scaling";

interface Props {
  onRecipeCreated: () => void;
}

const SUGGESTION_PROMPTS = [
  "A quick weeknight pasta",
  "Something with chicken and vegetables",
  "A vegetarian curry",
  "A simple dessert",
  "A healthy salad",
];

export function RecipeGenerator({ onRecipeCreated }: Props) {
  const [isOpen, setIsOpen] = useState(false);
  const [prompt, setPrompt] = useState("");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [generatedRecipe, setGeneratedRecipe] = useState<ParsedRecipe | null>(
    null
  );
  const [showPreview, setShowPreview] = useState(true);

  async function handleGenerate(text?: string) {
    const input = text || prompt.trim();
    if (!input || loading) return;

    setError(null);
    setGeneratedRecipe(null);
    setLoading(true);

    try {
      const result = await generateRecipe(input);
      setGeneratedRecipe(result.recipe);
      setShowPreview(true);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to generate recipe");
    } finally {
      setLoading(false);
    }
  }

  async function handleSave() {
    if (!generatedRecipe) return;

    try {
      const newRecipe = await createRecipe({
        title: generatedRecipe.title,
        description: generatedRecipe.description,
        servings: generatedRecipe.servings,
        prepTimeMinutes: generatedRecipe.prepTimeMinutes,
        cookTimeMinutes: generatedRecipe.cookTimeMinutes,
        sourceType: "text",
        sourceText: null,
        sourceContext: `Generated from prompt: ${prompt}`,
        ingredients: generatedRecipe.ingredients,
        steps: generatedRecipe.steps,
        tags: generatedRecipe.suggestedTags.map((tag) => ({
          tag,
          isAutoGenerated: true,
        })),
      });
      setGeneratedRecipe(null);
      setPrompt("");
      onRecipeCreated();
      route(`/recipe/${newRecipe.id}`);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to save recipe");
    }
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleGenerate();
    }
  }

  return (
    <div class="recipe-generator">
      <button
        class={`recipe-generator-toggle ${isOpen ? "open" : ""}`}
        onClick={() => setIsOpen(!isOpen)}
      >
        <span class="recipe-generator-icon">+</span>
        Create with AI
        <span class="recipe-generator-arrow">{isOpen ? "▲" : "▼"}</span>
      </button>

      {isOpen && (
        <div class="recipe-generator-content">
          <p class="recipe-generator-hint">
            Describe a recipe you'd like to create
          </p>

          <div class="recipe-generator-input-row">
            <input
              type="text"
              class="recipe-generator-input"
              value={prompt}
              onInput={(e) => setPrompt(e.currentTarget.value)}
              onKeyDown={handleKeyDown}
              placeholder="e.g., A creamy mushroom risotto"
              disabled={loading}
            />
            <button
              class="btn btn-primary"
              onClick={() => handleGenerate()}
              disabled={loading || !prompt.trim()}
            >
              {loading ? "Generating..." : "Generate"}
            </button>
          </div>

          {!generatedRecipe && !loading && (
            <div class="recipe-generator-suggestions">
              {SUGGESTION_PROMPTS.map((suggestion) => (
                <button
                  key={suggestion}
                  class="recipe-generator-suggestion"
                  onClick={() => {
                    setPrompt(suggestion);
                    handleGenerate(suggestion);
                  }}
                >
                  {suggestion}
                </button>
              ))}
            </div>
          )}

          {error && <div class="recipe-generator-error">{error}</div>}

          {generatedRecipe && (
            <div class="recipe-generator-result">
              <div class="recipe-generator-result-header">
                <span class="recipe-generator-result-title">
                  {generatedRecipe.title}
                </span>
                <button
                  class={`btn btn-small ${showPreview ? "active" : ""}`}
                  onClick={() => setShowPreview(!showPreview)}
                >
                  {showPreview ? "Hide" : "Preview"}
                </button>
              </div>

              {showPreview && (
                <div class="recipe-generator-preview">
                  {generatedRecipe.description && (
                    <p class="recipe-generator-description">
                      {generatedRecipe.description}
                    </p>
                  )}

                  <div class="recipe-generator-meta">
                    {generatedRecipe.servings && (
                      <span>Serves {generatedRecipe.servings}</span>
                    )}
                    {generatedRecipe.prepTimeMinutes && (
                      <span>Prep: {generatedRecipe.prepTimeMinutes}m</span>
                    )}
                    {generatedRecipe.cookTimeMinutes && (
                      <span>Cook: {generatedRecipe.cookTimeMinutes}m</span>
                    )}
                  </div>

                  {generatedRecipe.ingredients.length > 0 && (
                    <div class="recipe-generator-section">
                      <h4>Ingredients</h4>
                      <ul>
                        {generatedRecipe.ingredients.map((ing, i) => (
                          <li key={i}>
                            {ing.quantity && `${ing.quantity} `}
                            {ing.unit && `${ing.unit} `}
                            {ing.name}
                            {ing.notes && ` (${ing.notes})`}
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}

                  {generatedRecipe.steps.length > 0 && (
                    <div class="recipe-generator-section">
                      <h4>Method</h4>
                      <ol>
                        {generatedRecipe.steps.map((step, i) => (
                          <li key={i}>{renderStepText(step.instruction, 1)}</li>
                        ))}
                      </ol>
                    </div>
                  )}

                  {generatedRecipe.suggestedTags.length > 0 && (
                    <div class="recipe-generator-tags">
                      {generatedRecipe.suggestedTags.map((tag) => (
                        <span key={tag} class="tag-chip">
                          {tag}
                        </span>
                      ))}
                    </div>
                  )}
                </div>
              )}

              <div class="recipe-generator-actions">
                <button class="btn btn-primary" onClick={handleSave}>
                  Save Recipe
                </button>
                <button
                  class="btn"
                  onClick={() => handleGenerate()}
                  disabled={loading}
                >
                  Regenerate
                </button>
                <button
                  class="btn"
                  onClick={() => {
                    setGeneratedRecipe(null);
                    setPrompt("");
                  }}
                >
                  Dismiss
                </button>
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
}
